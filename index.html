<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Isometric Game</title>
    <style>
        canvas {
            background-color: black;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600" tabindex="1"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

canvas.focus(); // Focus the canvas to enable keyboard input

const tileSize = 32;
const playerColor = 'white';
const enemyColor = 'green';

const player = {
    x: 10,
    y: 10,
    color: playerColor
};

const lasers = [];

let enemies = [];

function spawnEnemies(count) {
    for (let i = 0; i < count; i++) {
        const enemy = {
            x: Math.floor(Math.random() * 10),
            y: Math.floor(Math.random() * 10),
            color: enemyColor
        };
        enemies.push(enemy);
    }
}

spawnEnemies(5);
function isoTo2D(x, y) {
    const offsetX = canvas.width / 2;
    const offsetY = canvas.height / 4;
    return {
        x: (x - y) + offsetX,
        y: (x + y) / 2 + offsetY
    };
}


function drawTile(x, y, color, size = tileSize) {
    const pos = isoTo2D(x * size, y * size);

    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y);
    ctx.lineTo(pos.x + size / 2, pos.y + size / 4);
    ctx.lineTo(pos.x, pos.y + size / 2);
    ctx.lineTo(pos.x - size / 2, pos.y + size / 4);
    ctx.closePath();

    ctx.fillStyle = color;
    ctx.fill();
}

// Collision detection
function isColliding(x, y) {
    if (x < 0 || x > 10 || y < 0 || y > 10) {
        return true;
    }

    for (let i = 0; i < enemies.length; i++) {
        const enemy = enemies[i];
        if (enemy.x === x && enemy.y === y) {
            return true;
        }
    }

    return false;
}

let lastFacingDirection = 'right';

function handleKeydown(event) {
    switch (event.key) {
        case 'ArrowUp':
            player.y--;
            lastFacingDirection = 'up';
            break;
        case 'ArrowDown':
            player.y++;
            lastFacingDirection = 'down';
            break;
        case 'ArrowLeft':
            player.x--;
            lastFacingDirection = 'left';
            break;
        case 'ArrowRight':
            player.x++;
            lastFacingDirection = 'right';
            break;
    }

    if (isColliding(player.x, player.y)) {
        switch (lastFacingDirection) {
            case 'up':
                player.y++;
                break;
            case 'down':
                player.y--;
                break;
            case 'left':
                player.x++;
                break;
            case 'right':
                player.x--;
                break;
        }
    }

    // Rotate the player sprite
    switch (lastFacingDirection) {
        case 'up':
            player.color = 'red';
            break;
        case 'down':
            player.color = 'blue';
            break;
        case 'left':
            player.color = 'yellow';
            break;
        case 'right':
            player.color = 'white';
            break;
    }
}

// Draw on the upper left corner of the canvas which direction the player is facing
function drawFacingDirection() {
    ctx.fillStyle = 'white';
    ctx.font = '30px Arial';
    ctx.fillText(`Facing: ${lastFacingDirection}`, 10, 30);
}


// Draw text on the canvas if enemies are killed
let killedEnemies = 0;
function drawText(text, x, y, color = 'white') {
    ctx.fillStyle = color;
    ctx.font = '30px Arial';
    ctx.fillText(text, x, y);
}

// Respawn enemies when they are killed
function respawnEnemies() {
    if (enemies.length === 0) {
        spawnEnemies(5);
    }
}


function shootLasers() {
    // Store the direction in which the laser was fired
    const firingDirection = lastFacingDirection;

    const laser = {
        x: player.x,
        y: player.y,
        color: player.color,
        intervalId: null,
        direction: firingDirection // Add the direction property to the laser
    };

    function moveLaser() {
        const dx = (laser.direction === 'left' ? -1 : (laser.direction === 'right' ? 1 : 0));
        const dy = (laser.direction === 'up' ? -1 : (laser.direction === 'down' ? 1 : 0));
        laser.x += dx;
        laser.y += dy;

        drawTile(laser.x, laser.y, laser.color);

        for (let i = 0; i < enemies.length; i++) {
            const enemy = enemies[i];
            if (laser.x === enemy.x && laser.y === enemy.y) {
                clearInterval(laser.intervalId);
                lasers.splice(lasers.indexOf(laser), 1);
                enemies.splice(i, 1);
                killedEnemies++;
                drawText(`Killed enemies: ${killedEnemies}`, 10, 50);
                respawnEnemies();
                return
            }
        }

        if (laser.y < 0 || laser.y > 10 || laser.x < 0 || laser.x > 10) {
            clearInterval(laser.intervalId);
            lasers.splice(lasers.indexOf(laser), 1);
        }

    }

    laser.intervalId = setInterval(moveLaser, 100);
    lasers.push(laser);
}



function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

// Draw grid lines for the map area
ctx.strokeStyle = 'rgba(128, 128, 128, 0.5)';
ctx.lineWidth = 1;

for (let i = 0; i <= 10; i++) {
    for (let j = 0; j <= 10; j++) {
        const topLeft = isoTo2D(i * tileSize, j * tileSize);
        const topRight = isoTo2D((i + 1) * tileSize, j * tileSize);
        const bottomLeft = isoTo2D(i * tileSize, (j + 1) * tileSize);
        const bottomRight = isoTo2D((i + 1) * tileSize, (j + 1) * tileSize);

        ctx.beginPath();
        ctx.moveTo(topLeft.x, topLeft.y);
        ctx.lineTo(topRight.x, topRight.y);
        ctx.lineTo(bottomRight.x, bottomRight.y);
        ctx.lineTo(bottomLeft.x, bottomLeft.y);
        ctx.closePath();
        ctx.stroke();
    }
}
    for (let i = 0; i < 10; i++) {
        for (let j = 0; j < 10; j++) {
              drawTile(i, j, 'black');
        }
    }

    for (let i = 0; i < enemies.length; i++) {
        const enemy = enemies[i];
        drawTile(enemy.x, enemy.y, enemy.color);
    }

    for (let i = 0; i < lasers.length; i++) {
        const laser = lasers[i];
        drawTile(laser.x, laser.y, laser.color);
    }
    // Rotate the player sprite based on the last facing direction
    

    drawTile(player.x, player.y, player.color);
}
let lightingValue = 0;
let lightingDirection = 1; // 1 for increasing, -1 for decreasing

function updateLighting() {
    lightingValue += 0.01 * lightingDirection;

    if (lightingValue >= 1) {
        lightingDirection = -1;
    } else if (lightingValue <= 0) {
        lightingDirection = 1;
    }
}

function applyLighting() {
    ctx.save();
    ctx.globalCompositeOperation = 'overlay';
    ctx.fillStyle = `rgba(0, 0, 0, ${lightingValue})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
}



function gameLoop() {
    updateLighting(); // Update the lighting value
    draw();
    applyLighting(); // Apply the lighting value to the canvas
    requestAnimationFrame(gameLoop);
    drawText(`Killed enemies: ${killedEnemies}`, 10, 60);

    drawFacingDirection();
}


canvas.addEventListener('keydown', handleKeydown);
canvas.addEventListener('keydown', event => {
    if (event.key === ' ') {
        shootLasers();
    }
});

gameLoop();
    </script>
</body>
</html>
